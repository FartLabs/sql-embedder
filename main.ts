import { parseArgs } from "@std/cli/parse-args";
import { expandGlob } from "@std/fs/expand-glob";
import { createParser } from "deno-tree-sitter";
import sql from "./sql.js";

if (import.meta.main) {
  await main();
}

/**
 * main is the entry point for the SQL embedder CLI tool.
 *
 * Searches for SQL files in the specified directory, parses them using tree-sitter,
 * # Process SQL files in current directory
 * deno task start
 *
 * # Process SQL files in specific directory
 * deno task start --dir ./queries
 * deno task start -d ./queries
 * deno task start ./queries
 * ```
 */
export async function main() {
  const flags = parseArgs(Deno.args, {
    string: ["dir"],
    alias: { dir: "d" },
  });
  const inputDir = flags.dir ?? flags._[0] ?? ".";

  const parser = await createParser(sql);
  for await (
    const entry of expandGlob("**/*.sql", { root: String(inputDir) })
  ) {
    const sourceCode = await Deno.readTextFile(entry.path);
    const ast = parser.parse(sourceCode);
    if (!ast) {
      throw new Error("Failed to parse SQL file: " + entry.path);
    }

    // Extract statements and preceding comments
    const statements: { comments: string[]; sql: string }[] = [];
    let pendingComments: string[] = [];

    for (const child of ast.rootNode.children) {
      if (child.type === "comment") {
        pendingComments.push(child.text);
      } else if (child.type === "statement") {
        statements.push({
          sql: child.text,
          comments: pendingComments,
        });
        pendingComments = [];
      } else {
        // Ignore whitespace and other nodes
      }
    }

    const seen = new Set<string>();
    let result =
      "// This file was generated by sql-embedder. Do not edit manually.\n\n";

    for (const statement of statements) {
      // Note: We use regex here because tree-sitter's query API matches patterns
      // but does not return the capture groups from the internal regex engine.
      // We must parse the comment text manually.
      const variableName = statement.comments
        .at(0)
        ?.match(/^--\s+(\w+)(\s|$)/)
        ?.at(1);
      if (!variableName) {
        console.warn(
          "Failed to extract variable name from statement. Skipping",
          statement,
        );
        continue;
      }

      if (seen.has(variableName)) {
        console.warn("Duplicate variable name: " + variableName);
        continue;
      }

      result += `/**\n`;
      for (const comment of statement.comments) {
        result += ` * ${comment.replace(/^--\s+/, "")}\n`;
      }
      result += ` */\n`;

      result += `export const ${variableName} = ${
        JSON.stringify(statement.sql)
      };\n\n`;
      seen.add(variableName);
    }

    const outPath = entry.path.replace(/(\.sql)$/, ".sql.ts");
    await Deno.writeTextFile(outPath, result);
  }
}
