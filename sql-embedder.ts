import { createParser } from "deno-tree-sitter";
import sql from "./sql.js";

const parser = await createParser(sql);

/**
 * embedSql generates a TypeScript module string from SQL source code.
 */
export function embedSql(sourceCode: string): string {
  const statements = parseSql(sourceCode);

  const seen = new Set<string>();
  let result =
    "// This file was generated by sql-embedder. Do not edit manually.\n\n";

  for (const statement of statements) {
    // Variable name from first (topmost) comment.
    const variableName = statement.comments
      .at(0)
      ?.match(/^--\s+(\w+)(\s|$)/)
      ?.at(1);
    // Format: -- variableName (description optional)
    if (!variableName) {
      console.warn(
        `No valid preceding comment for statement. Add "-- variableName" (description optional). Skipping.`,
        statement,
      );
      continue;
    }

    if (seen.has(variableName)) {
      console.warn("Duplicate variable name: " + variableName);
      continue;
    }

    result += `/**\n`;
    for (const comment of statement.comments) {
      result += ` * ${comment.replace(/^--\s+/, "")}\n`;
    }
    result += ` */\n`;

    result += `export const ${variableName} = ${
      JSON.stringify(statement.sql)
    };\n\n`;
    seen.add(variableName);
  }

  return result;
}

/**
 * ParsedSqlStatement represents a single parsed SQL statement.
 */
export interface ParsedSqlStatement {
  comments: string[];
  sql: string;
}

/**
 * splitErrorNode splits an ERROR node's text by embedded comment markers.
 * Tree-sitter returns ERROR nodes for unparseable SQL (like multi-line CREATE TRIGGER).
 * These ERROR nodes often contain multiple statements with embedded comments.
 * This function extracts those embedded statements.
 */
function splitErrorNode(errorText: string): ParsedSqlStatement[] {
  const results: ParsedSqlStatement[] = [];
  const lines = errorText.split("\n");

  let currentComments: string[] = [];
  let currentSql: string[] = [];

  for (const line of lines) {
    const trimmed = line.trim();

    if (trimmed.startsWith("--")) {
      // Found a comment line
      if (currentSql.length > 0) {
        // Save the previous statement
        results.push({
          sql: currentSql.join("\n"),
          comments: currentComments,
        });
        currentSql = [];
        currentComments = []; // Reset for next statement
      }
      currentComments.push(line);
    } else if (trimmed.length > 0) {
      // SQL content
      currentSql.push(line);
    } else if (currentSql.length > 0) {
      // Empty line - keep it as part of current SQL
      currentSql.push(line);
    }
  }

  // Don't forget the last statement
  if (currentSql.length > 0) {
    results.push({
      sql: currentSql.join("\n"),
      comments: currentComments,
    });
  }

  return results;
}

/**
 * parseSql parses SQL source code and returns an array of parsed SQL statements.
 */
export function parseSql(sourceCode: string): ParsedSqlStatement[] {
  const ast = parser.parse(sourceCode);
  if (!ast) {
    throw new Error("Failed to parse SQL source code");
  }

  const results: ParsedSqlStatement[] = [];
  let pendingComments: string[] = [];

  for (const child of ast.rootNode.children) {
    if (child.type === "comment") {
      pendingComments.push(child.text);
    } else if (child.type === "whitespace") {
      if (results.length > 0 && pendingComments.length === 0) {
        results[results.length - 1].sql += child.text;
      }
    } else if (child.type === ";") {
      if (results.length > 0) {
        results[results.length - 1].sql += child.text;
      }
    } else {
      // Handle ERROR nodes (e.g., multi-line CREATE TRIGGER statements)
      // Tree-sitter returns ERROR nodes for SQL it can't parse
      if (child.type === "ERROR") {
        // ERROR nodes may contain multiple embedded statements with comments
        // Split them out and add each as a separate statement
        const errorStatements = splitErrorNode(child.text);
        for (const stmt of errorStatements) {
          // Merge pending comments with the statement's own comments
          const allComments = [...pendingComments, ...stmt.comments];
          results.push({ sql: stmt.sql, comments: allComments });
          pendingComments = [];
        }
      } else {
        // Normal parsed statement
        if (pendingComments.length > 0 || results.length === 0) {
          results.push({ sql: child.text, comments: pendingComments });
          pendingComments = [];
        } else if (results.length > 0) {
          // Append to previous statement if no pending comments
          results[results.length - 1].sql += child.text;
        }
      }
    }
  }

  // Trim trailing whitespace from each statement's SQL
  for (const result of results) {
    result.sql = result.sql.trim();
  }

  return results;
}
