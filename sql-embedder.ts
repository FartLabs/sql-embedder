import { createParser } from "deno-tree-sitter";
import sql from "./sql.js";

const parser = await createParser(sql);

/**
 * embedSql generates a TypeScript module string from SQL source code.
 */
export function embedSql(sourceCode: string): string {
  const statements = parseSql(sourceCode);

  const seen = new Set<string>();
  let result =
    "// This file was generated by sql-embedder. Do not edit manually.\n\n";

  for (const statement of statements) {
    // Variable name from first (topmost) comment.
    const variableName = statement.comments
      .at(0)
      ?.match(/^--\s+(\w+)(\s|$)/)
      ?.at(1);
    // Format: -- variableName (description optional)
    if (!variableName) {
      console.warn(
        `No valid preceding comment for statement. Add "-- variableName" (description optional). Skipping.`,
        statement,
      );
      continue;
    }

    if (seen.has(variableName)) {
      console.warn("Duplicate variable name: " + variableName);
      continue;
    }

    result += `/**\n`;
    for (const comment of statement.comments) {
      result += ` * ${comment.replace(/^--\s+/, "")}\n`;
    }
    result += ` */\n`;

    result += `export const ${variableName} = ${
      JSON.stringify(statement.sql)
    };\n\n`;
    seen.add(variableName);
  }

  return result;
}

/**
 * ParsedSqlStatement represents a single parsed SQL statement.
 */
export interface ParsedSqlStatement {
  comments: string[];
  sql: string;
}

/**
 * parseSql parses SQL source code and returns an array of parsed SQL statements.
 */
export function parseSql(sourceCode: string): ParsedSqlStatement[] {
  const ast = parser.parse(sourceCode);
  if (!ast) {
    throw new Error("Failed to parse SQL source code");
  }

  const results: ParsedSqlStatement[] = [];
  let pendingComments: string[] = [];

  for (const child of ast.rootNode.children) {
    if (child.type === "comment") {
      pendingComments.push(child.text);
    } else if (child.type === "whitespace") {
      if (results.length > 0 && pendingComments.length === 0) {
        results[results.length - 1].sql += child.text;
      }
    } else if (child.type === ";") {
      if (results.length > 0) {
        results[results.length - 1].sql += child.text;
      }
    } else {
      if (pendingComments.length > 0 || results.length === 0) {
        results.push({ sql: child.text, comments: pendingComments });
        pendingComments = [];
      } else if (results.length > 0) {
        results[results.length - 1].sql += child.text;
      }
    }
  }

  // Trim trailing whitespace from each statement's SQL
  for (const result of results) {
    result.sql = result.sql.trim();
  }

  return results;
}
